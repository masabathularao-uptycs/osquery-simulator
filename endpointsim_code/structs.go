package main

import (
	"math"
	"net/http"
	"sort"
	"sync"
)

type ConfigRequest struct {
	NodeKey    string
	Index      int
	HttpChan   chan *HttpResponse
	HttpClient *http.Client
}

type DistReadRequest struct {
	Index      int
	HttpChan   chan *HttpResponse
	HttpClient *http.Client
}

type HttpResponse struct {
	url      string
	response *http.Response
	err      error
}

type ConfigMsg struct {
	NodeKey string `json:"node_key"`
}

type AutoGenerated struct {
	EnrollSecret   string      `json:"enroll_secret"`
	HostIdentifier string      `json:"host_identifier"`
	PlatformType   int         `json:"platform_type"`
	HostDetails    HostDetails `json:"host_details"`
}
type OsVersion struct {
	ID           string `json:"_id"`
	Codename     string `json:"codename"`
	Major        string `json:"major"`
	Minor        string `json:"minor"`
	Name         string `json:"name"`
	Patch        string `json:"patch"`
	Platform     string `json:"platform"`
	PlatformLike string `json:"platform_like"`
	Version      string `json:"version"`
}

type OsqueryInfo struct {
	BuildDistro   string `json:"build_distro"`
	BuildPlatform string `json:"build_platform"`
	ConfigHash    string `json:"config_hash"`
	ConfigValid   string `json:"config_valid"`
	Extensions    string `json:"extensions"`
	InstanceID    string `json:"instance_id"`
	Pid           string `json:"pid"`
	StartTime     string `json:"start_time"`
	Uuidv4        string `json:"uuidv4"`
	Version       string `json:"version"`
	Watcher       string `json:"watcher"`
}

type PlatformInfo struct {
	Address    string `json:"address"`
	Date       string `json:"date"`
	Extra      string `json:"extra"`
	Revision   string `json:"revision"`
	Size       string `json:"size"`
	Vendor     string `json:"vendor"`
	Version    string `json:"version"`
	VolumeSize string `json:"volume_size"`
}

type SystemInfo struct {
	ComputerName     string `json:"computer_name"`
	Hostname         string `json:"hostname"`
	LocalHostname    string `json:"local_hostname"`
	CPUBrand         string `json:"cpu_brand"`
	CPULogicalCores  string `json:"cpu_logical_cores"`
	CPUPhysicalCores string `json:"cpu_physical_cores"`
	CPUSubtype       string `json:"cpu_subtype"`
	CPUType          string `json:"cpu_type"`
	HardwareModel    string `json:"hardware_model"`
	HardwareSerial   string `json:"hardware_serial"`
	HardwareVendor   string `json:"hardware_vendor"`
	HardwareVersion  string `json:"hardware_version"`
	PhysicalMemory   string `json:"physical_memory"`
	UUID             string `json:"uuid"`
}

type HostDetails struct {
	OsVersion    OsVersion    `json:"os_version"`
	OsqueryInfo  OsqueryInfo  `json:"osquery_info"`
	PlatformInfo PlatformInfo `json:"platform_info"`
	SystemInfo   SystemInfo   `json:"system_info"`
}

type DistributedWriteBody struct {
	Queries map[string]map[string]interface{} `json:"queries"`
}

type LogMessage struct {
	NodeKey string                   `json:"node_key"`
	LogType string                   `json:"log_type"`
	Data    []map[string]interface{} `json:"data"`
}

type LogGoRoutineMsg struct {
	ToPost []byte
	Client *http.Client
}

type distReadReq struct {
	NodeKey string `json:"node_key"`
}

type Histogram struct {
	Records []float32
}

func (h *Histogram) add(val float32, m *sync.Mutex) {
	m.Lock()
	h.Records = append(h.Records, val)
	m.Unlock()
}

func (h Histogram) min() float32 {
	if len(h.Records) == 0 {
		return float32(0)
	} else {
		m := h.Records[0]
		for _, val := range h.Records {
			if val < m {
				m = val
			}
		}
		return m
	}
}

func (h Histogram) max() float32 {
	if len(h.Records) == 0 {
		return float32(0)
	} else {
		m := h.Records[0]
		for _, val := range h.Records {
			if val > m {
				m = val
			}
		}
		return m
	}
}

func (h Histogram) mean() float32 {
	if len(h.Records) == 0 {
		return float32(0)
	} else {
		c := 0
		s := float32(0)
		for _, val := range h.Records {
			c += 1
			s += val
		}
		return s / float32(c)
	}
}

func (h Histogram) median() float32 {
	if len(h.Records) == 0 {
		return float32(0)
	} else {
		sort.Sort(ByFloat(h.Records))
		l := len(h.Records)
		if l%2 == 0 {
			left_ele := math.Floor(float64(l)/2 - 1)
			right_ele := math.Floor(float64(l) / 2)
			s := h.Records[int(left_ele)] + h.Records[int(right_ele)]
			return float32(s / 2)
		} else {
			pos := math.Floor(float64(l) / 2)
			return h.Records[int(pos)]
		}

	}
}

type ByFloat []float32

func (a ByFloat) Len() int           { return len(a) }
func (a ByFloat) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByFloat) Less(i, j int) bool { return a[i] < a[j] }
