package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	_ "net/http/pprof"
	"strconv"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	uuid "github.com/nu7hatch/gouuid"
	"github.com/rafaeldias/async"
)

func generate_enroll_body(host_name, uuidv4 string) AutoGenerated {
	ov := make_os_version(host_name)
	osqi := make_osquery_info(uuidv4)
	si := make_system_info(host_name, uuidv4)
	hd := HostDetails{
		OsVersion:    ov,
		OsqueryInfo:  osqi,
		SystemInfo:   si,
		PlatformInfo: platform_info,
	}
	return AutoGenerated{
		//EnrollSecret: "2887a6da-df43-46fa-b6db-5a9d8da09cc4##2887a6da-df43-46fa-b6db-5a9d8da09cc4", // auto
		//EnrollSecret:   "19fe4fff-ab86-4264-8fba-dc8eea1ad6ef##19fe4fff-ab86-4264-8fba-dc8eea1ad6ef",
		EnrollSecret:   secret,
		HostIdentifier: uuidv4,
		PlatformType:   9,
		HostDetails:    hd,
	}

}

func make_os_version(hostname string) OsVersion {
	return OsVersion{
		ID:           hostname,
		Codename:     "jammy",
		Major:        "22",
		Minor:        "4",
		Name:         "Ubuntu",
		Patch:        "4",
		Platform:     "ubuntu",
		PlatformLike: "debian",
		Version:      "22.04.4",
	}
}

func make_osquery_info(uuidv4 string) OsqueryInfo {
	uuid, uerr := uuid.NewV4()
	if uerr != nil {
		log.Fatalf("Got error generating uuid: %v", uerr)
	}
	return OsqueryInfo{
		BuildDistro:   "xenial",
		BuildPlatform: "ubuntu",
		ConfigHash:    "",
		ConfigValid:   "0",
		Extensions:    "active",
		InstanceID:    uuid.String(),
		Pid:           "121",
		StartTime:     "1710429552",
		Uuidv4:        uuidv4,
		Version:       "5.11.0-Uptycs",
		Watcher:       "175",
	}
}

func make_platform_info() PlatformInfo {
	return PlatformInfo{
		Address:    "0xf000",
		Date:       "07/07/2016",
		Extra:      "",
		Revision:   "1.12",
		Size:       "16777216",
		Vendor:     "HP",
		Version:    "N82 Ver. 01.12",
		VolumeSize: "0",
	}
}

func make_system_info(host_name, uuidv4 string) SystemInfo {
	return SystemInfo{
		ComputerName:     host_name,
		Hostname:         host_name,
		LocalHostname:    host_name,
		CPUBrand:         "Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz\u0000\u0000\u0000\u0000\u0000\u0000\u0000",
		CPULogicalCores:  "8",
		CPUPhysicalCores: "8",
		CPUSubtype:       "94",
		CPUType:          "6",
		HardwareModel:    "HP ZBook Studio G3",
		HardwareSerial:   "CND60233F6",
		HardwareVendor:   "HP",
		HardwareVersion:  "",
		PhysicalMemory:   "25199255552",
		UUID:             uuidv4,
	}
}

func NewLogMessage(node_key string, obj []map[string]interface{}) LogMessage {
	return LogMessage{
		NodeKey: node_key,
		LogType: "result",
		Data:    obj,
	}
}

func localize_syncmap(m *sync.Map) map[interface{}]interface{} {
	s := make(map[interface{}]interface{})
	m.Range(func(k, v interface{}) bool {
		s[k] = v
		return true
	})
	return s
}

func get_node_key(i int) string {
	m := localize_syncmap(node_key)
	if val, ok := m[i]; ok {
		k := val.(string)
		return k
	} else {
		return ""
	}
}

func enroll_goroutine(url string, i int, ch chan *HttpResponse, client *http.Client) {
	ee := generate_enroll_body(random_names[i], random_uuids[i])
	eej, _ := json.Marshal(ee)
	//fmt.Println(i)
	//fmt.Println(ee)
	//fmt.Println(eej)
	//fmt.Println(url)
	start_req := time.Now()
	//fmt.Println(bytes.NewBuffer(eej))
	reqt, err := http.NewRequest("POST", url, bytes.NewBuffer(eej))
	reqt.Header.Set("Content-type", "application/json")
	reqt.Header.Set("User-Agent", "osquery/5.11.0.8-Uptycs")
	resp, errs := client.Do(reqt)
	//      resp, err := client.Post(url, "application/json", bytes.NewBuffer(eej))
	//fmt.Println(resp)
	elapsed := time.Since(start_req).Milliseconds()
	enroll_histogram.add(float32(elapsed), &enroll_histogram_mux)
	if errs != nil {
		log.Fatalln("errs", errs)
	}
	if err != nil {
		log.Fatalln(err)
	}
	var tesult map[string]interface{}
	//fmt.Println("=======")
	json.NewDecoder(resp.Body).Decode(&tesult)
	//fmt.Println("=======")
	//fmt.Println(tesult)
	if tesult["node_invalid"] == false {
		key := tesult["node_key"].(string)
		node_key.Store(i, key)

	}
	resp.Body.Close()
	ch <- &HttpResponse{url, resp, err}
}

func sendEnroll(url string) []*HttpResponse {
	ch := make(chan *HttpResponse, count) // buffered
	responses := []*HttpResponse{}
	for i := 0; i < count; i++ {
		if i%enrollbatchsize == 0 {
			time.Sleep(1 * time.Second)
		}
		time.Sleep(1 * time.Nanosecond)

		go enroll_goroutine(enrollurl, i, ch, get_enroll_client(i))
	}

	for {
		select {
		case r := <-ch:
			// fmt.Printf("%s was fetched\n", r.url)
			responses = append(responses, r)
			if len(responses) == count {
				return responses
			}
		case <-time.After(150 * time.Second):
			fmt.Printf(".")
		}
	}
}

func enroll() {
	var wg sync.WaitGroup
	wg.Add(1)
	results := sendEnroll(enrollurl)
	for index, result := range results {
		if result.response.Status != "200 OK" {
			enroll_fail_counter += 1
			log.Println("Failed enrolling index", index)
		} else {
			if index%50 == 0 || index == (count-1) {
				log.Println("Successfully enrolled", index)
			}
		}
	}
	time.Sleep(5 * time.Second)
	//go genconfig()
	wg.Wait()
}

func config_goroutine(node_key string, i int, http_chan chan *HttpResponse, client *http.Client) {
	//fmt.Println("node in config",node_key)
	ee := &ConfigMsg{NodeKey: node_key}
	eej, _ := json.Marshal(ee)
	start_req := time.Now()
	reqt, err := http.NewRequest("POST", configurl, bytes.NewBuffer(eej))
	//resp, err := client.Post(configurl, "application/json", bytes.NewBuffer(eej))
	reqt.Header.Set("Content-type", "application/json")
	reqt.Header.Set("User-Agent", "osquery/4.6.4.8-Uptycs")
	resp, errs := client.Do(reqt)
	elapsed := time.Since(start_req).Milliseconds()
	if errs != nil {
		log.Fatalln("errs", errs)
	}

	config_histogram.add(float32(elapsed), &config_histogram_mux)

	var tesult map[string]interface{}
	//log.Println("Status code:", resp.Status)
	if resp.Status != "200 OK" {
		json.NewDecoder(resp.Body).Decode(&tesult)
		if tesult["node_invalid"] == true {
			ch := make(chan *HttpResponse)
			fmt.Println("\nPlease re-enroll asset id", i)
			go enroll_goroutine(enrollurl, i, ch, get_enroll_client(i))
			fmt.Println("Send re-enroll request")
		}
	}
	resp.Body.Close()
	http_chan <- &HttpResponse{configurl, resp, err}

}

func post_to_logger(tstamp, name, uuidv4, node_key string, jsonMap LogMessage, client *http.Client, index int) {
	jsonMap.NodeKey = node_key
	for _, data := range jsonMap.Data {
		if _, ok := data["hostIdentifier"]; ok {
			data["hostIdentifier"] = uuidv4
		} else {
			fmt.Println("No hostIdentifier in data")
		}

		if _, ok := data["unixTime"]; ok {
			tstamp_int, tstamp_err := strconv.ParseInt(tstamp, 10, 32)
			if tstamp_err != nil {
				panic(tstamp_err)
			}
			data["unixTime"] = tstamp_int
		}

		if _, ok := data["hostname"]; ok {
			data["hostname"] = name
		}

		if _, ok := data["snapshot"]; ok {
			snd := data["snapshot"].([]interface{})
			for _, val := range snd {
				converted := val.(map[string]interface{})
				if _, ok := converted["hostname"]; ok {
					converted["hostname"] = name
				}
			}
		}
	}

	msg_json, unmarshalErr := json.Marshal(jsonMap)
	if unmarshalErr != nil {
		log.Fatalf(unmarshalErr.Error())
	}
	target := log_channels[index%num_log_channels]
	target <- LogGoRoutineMsg{ToPost: msg_json, Client: client}

}

func log_goroutine(to_post []byte, cli *http.Client) {
	//fmt.Println("to_post",string(to_post))

	start_req := time.Now()
	//fmt.Println(ect.TypeOf(to_post))
	resp, postErr := cli.Post(logurl, "application/json", bytes.NewBuffer(to_post))
	//resp, postErr := cli.Post(logurl, "application/json", bytes.NewBufferString(bufe.String()))
	if postErr != nil {
		log.Fatalf(postErr.Error())
	}
	resp.Header.Set("Content-Encoding", "gzip")
	elapsed := time.Since(start_req).Milliseconds()
	log_histogram.add(float32(elapsed), &log_histogram_mux)

	var result map[string]interface{}
	json.NewDecoder(resp.Body).Decode(&result)
	//fmt.Println(result)
	//fmt.Println(resp)
	if resp.Status != "200 OK" {
		log.Println("bad status code from log")
		log_fail_counter += 1
	}
	resp.Body.Close()

}

func single_threaded_log(tstamp string, jsonMap LogMessage) {
	for index, name := range random_names {
		uuidv4 := random_uuids[index]
		post_to_logger(tstamp, name, uuidv4, get_node_key(index), jsonMap, logClients[index], index)
	}
}

func post_message(c *gin.Context) {

	l := c.Request.ContentLength

	buf := make([]byte, l)
	res := ""
	for {
		n, err := c.Request.Body.Read(buf)
		res += string(buf[:n])
		if err == io.EOF {
			break
		}

	}

	tstamp := res[0:10]
	//fmt.Println("tstamp",tstamp)
	//fmt.Println(res[10:])
	var jsonMap LogMessage
	err := json.Unmarshal([]byte(res[10:]), &jsonMap)
	if err != nil {
		panic(err)
	}

	c.JSON(200, gin.H{})
	single_threaded_log(tstamp, jsonMap)
}

func get_enroll_client(index int) *http.Client {
	return enrollClients[index]
}

func main() {
	//defer profile.Start(profile.CPUProfile, profile.ProfilePath(".")).Stop()
	//go log.Println(http.ListenAndServe("localhost:8080", nil))
	go print_timers()
	gin.SetMode(gin.ReleaseMode)

	serv := gin.Default()
	//serv.Use(gzip.DefaultHandler().Gin)
	serv.POST("/", post_message)
	fmt.Println("Post", port)
	go serv.Run(":" + string(port))
	_, e := async.Concurrent(async.Tasks{
		func() int {
			time.Sleep(3 * time.Second)
			enroll()
			return 0
		},
	})

	if e != nil {
		fmt.Printf("Errors [%s]\n", e.Error()) // output errors separated by space
	}

}

func print_timers() {
	for {
		time.Sleep(time.Second * time.Duration(print_timer_sleep_time))
		print_timer("Enroll", enroll_fail_counter, enroll_histogram)
		print_timer("Config", config_fail_counter, config_histogram)
		print_timer("Log", log_fail_counter, log_histogram)
		print_timer("Distrubted_Read", dist_read_fail_counter, dist_read_histogram)
		print_timer("Distributed_Write", dist_write_fail_counter, dist_write_histogram)
		log.Println("Re-enrolled assets:", reenroll_count)
		log.Println("")
	}
}

func print_timer(name string, failed int, h Histogram) {
	log.Println("  ", name, "Failed:", failed, "Count:", len(h.Records), "Min:", h.min(), "Max:", h.max(),
		"Mean:", h.mean(), "Median:", h.median())
}
